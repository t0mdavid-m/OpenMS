// Copyright (c) 2002-present, The OpenMS Team -- EKU Tuebingen, ETH Zurich, and FU Berlin
// SPDX-License-Identifier: BSD-3-Clause
//
// --------------------------------------------------------------------------
// $Maintainer: Kyowon Jeong, Jihyung Kim $
// $Authors: Kyowon Jeong, Jihyung Kim $
// --------------------------------------------------------------------------

#include <OpenMS/ANALYSIS/TOPDOWN/DeconvolvedSpectrum.h>
#include <OpenMS/ANALYSIS/TOPDOWN/FLASHDeconvAlgorithm.h>
#include <OpenMS/ANALYSIS/TOPDOWN/FLASHIda.h>
#include <OpenMS/ANALYSIS/TOPDOWN/MassFeatureTrace.h>
#include <OpenMS/ANALYSIS/TOPDOWN/PeakGroup.h>
#include <OpenMS/ANALYSIS/TOPDOWN/Qvalue.h>
#include <OpenMS/ANALYSIS/TOPDOWN/TopDownIsobaricQuantifier.h>
#include <OpenMS/FILTERING/TRANSFORMERS/SpectraMerger.h>
#include <OpenMS/FILTERING/TRANSFORMERS/ThresholdMower.h>
#include <OpenMS/METADATA/SpectrumLookup.h>
#ifdef _OPENMP
  #include <omp.h>
#endif

namespace OpenMS
{
  inline const Size max_peak_count_for_centroid_ = 3e4;
  inline const Size max_peak_count_for_profile_ = 1e5;

  FLASHDeconvAlgorithm::FLASHDeconvAlgorithm() : DefaultParamHandler("FLASHDeconvAlgorithm"), ProgressLogger()
  {
    // FLASHIda log file read somehwere. ida_log_file_ should be updated.
    defaults_.setValue("ida_log", "", "log file generated by FLASHIda (IDA*.log). Only needed for coupling with FLASHIda acquisition");
    defaults_.setValue("report_FDR", "false", "Report qvalues (roughly, point-wise FDR) for deconvolved masses. Decoy masses to calculate qvalues and FDR are also reported. Beta version.");
    defaults_.setValidStrings("report_FDR", {"true", "false"});

    defaults_.setValue("allowed_isotope_error", 0,
                       "Allowed isotope index error for decoy and FDR report. If it is set to 2, for example, +-2 isotope errors are "
                       "not counted as false. Beta version.");
    defaults_.addTag("allowed_isotope_error", "advanced");

    defaults_.setValue("use_RNA_averagine", "false", "If set, RNA averagine model is used.");
    defaults_.setValidStrings("use_RNA_averagine", {"true", "false"});
    defaults_.addTag("use_RNA_averagine", "advanced");

    defaults_.setValue("preceding_MS1_count", 3,
                       "Specifies the number of preceding MS1 spectra for MS2 precursor determination. "
                       "In TDP, the precursor peak of a MS2 spectrum may not belong to any "
                       "deconvolved masses in the MS1 spectrum immediately preceding the MS2 spectrum. "
                       "Increasing this parameter to N allows for the search for the deconvolved masses in the N preceding MS1 spectra from the MS2 spectrum"
                       ", increasing the chance that its precursor is deconvolved.");
    defaults_.setMinInt("preceding_MS1_count", 1);
    defaults_.addTag("preceding_MS1_count", "advanced");

    defaults_.setValue("isolation_window", 5.0, "Default isolation window with. If the input mzML file does not contain isolation window width information, this width will be used.");
    defaults_.addTag("isolation_window", "advanced");

    // defaults_.setValue("max_MS_level", 2, "Maximum MS level (inclusive) for deconvolution.");
    // defaults_.setMinInt("max_MS_level", 1);
    // defaults_.addTag("max_MS_level", "advanced");

    defaults_.setValue("forced_MS_level", 0,
                       "If set to an integer N, MS level of all spectra will be set to N regardless of original MS level. Useful when deconvolving datasets containing only MS2 spectra.");
    defaults_.setMinInt("forced_MS_level", 0);
    defaults_.addTag("forced_MS_level", "advanced");

    defaults_.setValue("merging_method", 0,
                       "Method for spectra merging before deconvolution. 0: No merging  1: Average gaussian method to perform moving gaussian averaging of spectra per MS level. Effective to increase "
                       "proteoform ID sensitivity (in particular for Q-TOF datasets). 2: Block method to perform merging of all spectra into a single one per MS level (e.g., for NativeMS datasets).");
    defaults_.setMinInt("merging_method", 0);
    defaults_.setMaxInt("merging_method", 2);

    auto sd_defaults = SpectralDeconvolution().getDefaults();
    sd_defaults.remove("allowed_isotope_error");
    defaults_.insert("SD:", sd_defaults);

    Param mf_defaults = MassFeatureTrace().getDefaults();
    mf_defaults.setValue("min_cos", -1.0, "Cosine similarity threshold between avg. and observed isotope pattern.  When negative, MS1 cosine threshold for mass deconvolution will be used ");
    mf_defaults.setValue("mass_error_ppm", -1.0, "Feature tracing mass ppm tolerance. When negative, MS1 tolerance for mass deconvolution will be used (e.g., 16 ppm is used when -SD:tol 16).");
    mf_defaults.addTag("min_cos", "advanced");
    mf_defaults.addTag("mass_error_ppm", "advanced");

    mf_defaults.remove("noise_threshold_int");
    mf_defaults.remove("reestimate_mt_sd");
    mf_defaults.remove("trace_termination_criterion");
    mf_defaults.remove("trace_termination_outliers");
    mf_defaults.remove("chrom_peak_snr");

    defaults_.insert("ft:", mf_defaults);
    defaults_.insert("iq:", TopDownIsobaricQuantifier().getDefaults());

    defaultsToParam_();
  }

  void FLASHDeconvAlgorithm::updateMembers_()
  {
    forced_ms_level_ = param_.getValue("forced_MS_level");
    // max_ms_level_ = param_.getValue("max_MS_level");

    tols_ = param_.getValue("SD:tol");
    min_cos_ = param_.getValue("SD:min_cos");
    preceding_MS1_count_ = param_.getValue("preceding_MS1_count");
    use_RNA_averagine_ = param_.getValue("use_RNA_averagine") != "false";
    report_decoy_ = param_.getValue("report_FDR") != "false";

    merge_spec_ = param_.getValue("merging_method");
    isolation_window_size_ = param_.getValue("isolation_window");
    ida_log_file_ = param_.getValue("ida_log").toString();
    current_min_ms_level_ = max_ms_level_;
    current_max_ms_level_ = 0;
  }

  void FLASHDeconvAlgorithm::updateMSLevels_(MSExperiment& map)
  {
    // read input dataset once to count spectra
    for (auto& it : map)
    {
      // if forced_ms_level > 0, force MS level of all spectra to 1.
      if (forced_ms_level_ > 0)
      {
        it.setMSLevel(forced_ms_level_);
      }

      if (it.empty())
      {
        continue;
      }

      if (it.getMSLevel() > max_ms_level_)
      {
        continue;
      }

      uint ms_level = it.getMSLevel();
      current_max_ms_level_ = current_max_ms_level_ < ms_level ? ms_level : current_max_ms_level_;
      current_min_ms_level_ = current_min_ms_level_ > ms_level ? ms_level : current_min_ms_level_;
    }
    // Max MS Level is adjusted according to the input dataset
    current_max_ms_level_ = current_max_ms_level_ > max_ms_level_ ? max_ms_level_ : current_max_ms_level_;
  }

  void FLASHDeconvAlgorithm::filterLowPeaks_(MSExperiment& map)
  {
    OPENMS_LOG_INFO << "Filtering low peaks in spectra ... " << std::endl;
    ThresholdMower threshold_mower_filter;                         // threshold
    Param t_filter_param = threshold_mower_filter.getParameters(); //"threshold", .00001
    t_filter_param.setValue("threshold", 1e-6);
    threshold_mower_filter.setParameters(t_filter_param);
    threshold_mower_filter.filterPeakMap(map);

    for (auto& it : map)
    {
      if (it.empty()) continue;
      Size count = it.getType(false) == SpectrumSettings::CENTROID ? max_peak_count_for_centroid_ : max_peak_count_for_profile_;
      it.sortByIntensity(true);
      double threshold = it.size() < count ? 0 : it[count].getIntensity();
      threshold = std::max(threshold, (double)it.begin()->getIntensity() / 1000);
      // pop back the low intensity peaks using threshold

      while (!it.empty() && it.back().getIntensity() <= threshold)
      {
        it.pop_back();
      }
      it.sortByPosition();
    }
    OPENMS_LOG_INFO << "Done"<<std::endl;
  }

  void FLASHDeconvAlgorithm::mergeSpectra_(MSExperiment& map, uint ms_level)
  {
    SpectraMerger merger;
    merger.setLogType(CMD);
    Param sm_param = merger.getDefaults();
    sm_param.setValue("mz_binning_width", tols_[ms_level - 1]);
    sm_param.setValue("mz_binning_width_unit", "ppm");

    if (merge_spec_ == 1)
    {
      if (ms_level == 1)
      {
        OPENMS_LOG_INFO << "Gaussian averaging MS1 spectra ... " << std::endl;
        merger.setParameters(sm_param);
        map.sortSpectra();
        merger.average(map, "gaussian", (int)ms_level);
      }
      else
      {
        // For ms n, first find precursors for all ms n. then make a tmp map having the precursor masses as precursor
        std::map<String, std::vector<Precursor>> original_precursor_map;
        for (Size i = 0; i < map.size(); i++)
        {
          auto spec = map[i];
          if (spec.getMSLevel() != ms_level)
            continue;

          auto native_id = spec.getNativeID();
          original_precursor_map[native_id] = spec.getPrecursors();

          if (!spec.getPrecursors().empty() && native_id_precursor_peak_group_map_.find(native_id) != native_id_precursor_peak_group_map_.end())
          {
            auto precursor_pg = native_id_precursor_peak_group_map_[native_id];
            auto precursor = spec.getPrecursors()[0];
            precursor.setCharge(1);
            precursor.setMZ(precursor_pg.getMonoMass());
            precursor.setIntensity(precursor_pg.getIntensity());
            map[i].setPrecursors(std::vector<Precursor> {precursor});
          }
        }
        // merge MS n using precursor method
        OPENMS_LOG_INFO << "Averaging MS" << ms_level << " spectra from the same deconvolved precursor masses... " << std::endl;
        sm_param.setValue("precursor_method:mz_tolerance", 0.2);
        sm_param.setValue("precursor_method:rt_tolerance", 5.0);
        merger.setParameters(sm_param);
        map.sortSpectra();
        merger.mergeSpectraPrecursors(map);

        for (auto& mspec : map)
        {
          auto native_id_str = mspec.getNativeID();
          std::vector<String> native_ids;
          native_id_str.split(",", native_ids);

          for (auto& native_id : native_ids)
          {
            if (original_precursor_map.find(native_id) == original_precursor_map.end())
              continue;
            // auto precursor = original_precursor_map[native_id];
            mspec.setPrecursors(original_precursor_map[native_id]);
          }
        }
      }
    }
    else if (merge_spec_ == 2)
    {
      OPENMS_LOG_INFO << "Merging spectra into a single spectrum for MS" << ms_level << std::endl;
      sm_param.setValue("block_method:rt_block_size", map.size() + 1);
      map.sortSpectra();
      sm_param.setValue("block_method:ms_levels", IntList {(int)ms_level});
      merger.setParameters(sm_param);
      merger.mergeSpectraBlockWise(map);
    }

    filterLowPeaks_(map);
  }

  int FLASHDeconvAlgorithm::getScanNumber_(const MSExperiment& map, Size index)
  {
    auto native_id_str = map[index].getNativeID();
    std::vector<String> native_ids;
    native_id_str.split(",", native_ids);

    if (map.getSourceFiles().empty())
    {
      return (int)index + 1;
    }

    auto type_accession = map.getSourceFiles()[0].getNativeIDTypeAccession();
    if (type_accession.empty())
      type_accession = "MS:1000768";

    int scan_number = SpectrumLookup::extractScanNumber(native_ids.back(), type_accession);
    if (scan_number < 0)
    {
      scan_number = (int)index + 1;
    }

    return scan_number;
  }

  void FLASHDeconvAlgorithm::runSpectralDeconvolution_(MSExperiment& map, std::vector<DeconvolvedSpectrum>& deconvolved_spectra)
  {
    // merge spectra if the merging option is turned on (> 0)
    filterLowPeaks_(map);
    startProgress(0, (SignedSize)map.size(), "running FLASHDeconv");
    for (uint ms_level = 1; ms_level <= current_max_ms_level_; ms_level++)
    {
      if (ms_level > 1)
      {
        // here, register precursor peak groups to the ms2 spectra.
        findPrecursorPeakGroupsForMSnSpectra_(map, deconvolved_spectra, ms_level);
      }
      if (merge_spec_ > 0)
      {
        mergeSpectra_(map, ms_level);
        // repeat precursor peak group registration for merged/averaged spectra
        if (ms_level > 1 && merge_spec_ > 0)
        {
          // here, register precursor peak groups to the ms2 spectra.
          findPrecursorPeakGroupsForMSnSpectra_(map, deconvolved_spectra, ms_level);
        }
      }

      // run Spectral deconvolution
      for (Size index = 0; index < map.size(); index++)
      {
        int scan_number = getScanNumber_(map, index);
        auto spec = map[index];

        if (spec.empty())
        {
          continue;
        }

        if (ms_level != spec.getMSLevel())
        {
          continue;
        }
        String native_id = spec.getNativeID();

        PeakGroup precursor_pg; // TODO implement decoy precursor peak group
        if (native_id_precursor_peak_group_map_.find(native_id) != native_id_precursor_peak_group_map_.end())
          precursor_pg = native_id_precursor_peak_group_map_[native_id];

        // now do it

        sd_.performSpectrumDeconvolution(spec, scan_number, precursor_pg);

        auto& deconvolved_spectrum = sd_.getDeconvolvedSpectrum();

        if (deconvolved_spectrum.empty())
        {
          continue;
        }

        if (report_decoy_)
        {
#pragma omp parallel sections default(none) shared(spec, scan_number, precursor_pg)
          {
#pragma omp section
            sd_charge_decoy_.performSpectrumDeconvolution(spec, scan_number, precursor_pg);
#pragma omp section
            sd_noise_decoy_.performSpectrumDeconvolution(spec, scan_number, precursor_pg);
#pragma omp section
            sd_isotope_decoy_.performSpectrumDeconvolution(spec, scan_number, precursor_pg);
          }
          DeconvolvedSpectrum decoy_deconvolved_spectrum(scan_number);

          deconvolved_spectrum.sortByQscore();
          double qscore_threshold_for_decoy = deconvolved_spectrum.back().getQscore2D();

          decoy_deconvolved_spectrum.setOriginalSpectrum(spec);
          decoy_deconvolved_spectrum.reserve(sd_isotope_decoy_.getDeconvolvedSpectrum().size() + sd_charge_decoy_.getDeconvolvedSpectrum().size() + sd_noise_decoy_.getDeconvolvedSpectrum().size());

          for (auto& pg : sd_charge_decoy_.getDeconvolvedSpectrum())
            if (pg.getQscore2D() >= qscore_threshold_for_decoy)
              decoy_deconvolved_spectrum.push_back(pg);

          for (auto& pg : sd_isotope_decoy_.getDeconvolvedSpectrum())
            if (pg.getQscore2D() >= qscore_threshold_for_decoy)
              decoy_deconvolved_spectrum.push_back(pg);

          for (auto& pg : sd_noise_decoy_.getDeconvolvedSpectrum())
            if (pg.getQscore2D() >= qscore_threshold_for_decoy)
              decoy_deconvolved_spectrum.push_back(pg);

          decoy_deconvolved_spectrum.sort();
          deconvolved_spectrum.sort();

          if (!decoy_deconvolved_spectrum.empty())
            deconvolved_spectra.push_back(decoy_deconvolved_spectrum);
        }

        deconvolved_spectra.push_back(deconvolved_spectrum);
        nextProgress();
      }
      std::sort(deconvolved_spectra.begin(), deconvolved_spectra.end());
    }
    endProgress();
  }


  const FLASHDeconvHelperStructs::PrecalculatedAveragine& FLASHDeconvAlgorithm::getAveragine()
  {
    return sd_.getAveragine();
  }

  void FLASHDeconvAlgorithm::run(MSExperiment& map, std::vector<DeconvolvedSpectrum>& deconvolved_spectra, std::vector<FLASHDeconvHelperStructs::MassFeature>& deconvolved_features)
  {
    // initialize
    precursor_map_for_ida_ = FLASHIda::parseFLASHIdaLog(ida_log_file_); // ms1 scan -> mass, charge ,score, mz range, precursor int, mass int, color

    updateMSLevels_(map);

    sd_ = SpectralDeconvolution();
    Param sd_param = param_.copy("SD:", true);
    sd_param.setValue("allowed_isotope_error", param_.getValue("allowed_isotope_error"));
    sd_.setParameters(sd_param);
    sd_.calculateAveragine(use_RNA_averagine_);
    auto avg = sd_.getAveragine();

    if (report_decoy_)
    {
      sd_noise_decoy_.setParameters(sd_param);
      sd_noise_decoy_.setAveragine(avg);
      sd_noise_decoy_.setTargetDecoyType(PeakGroup::TargetDecoyType::noise_decoy, sd_.getDeconvolvedSpectrum()); // noise

      sd_isotope_decoy_.setParameters(sd_param);
      sd_isotope_decoy_.setAveragine(avg);
      sd_isotope_decoy_.setTargetDecoyType(PeakGroup::TargetDecoyType::isotope_decoy, sd_.getDeconvolvedSpectrum()); // isotope

      sd_charge_decoy_.setParameters(sd_param);
      sd_charge_decoy_.setAveragine(avg);
      sd_charge_decoy_.setTargetDecoyType(PeakGroup::TargetDecoyType::charge_decoy, sd_.getDeconvolvedSpectrum()); // charge
    }

    setLogType(CMD);
    deconvolved_spectra.reserve(map.size() * 4);

    // run spectral deconvolution here and get deconvolved spectra
    runSpectralDeconvolution_(map, deconvolved_spectra);

    // feature tracing here and update FeatureQScores
    runFeatureFinding_(deconvolved_spectra, deconvolved_features);

    noise_decoy_weight_ = Qvalue::updatePeakGroupQvalues(deconvolved_spectra);

    TopDownIsobaricQuantifier quantifier;
    Param quant_param = param_.copy("iq:", true);
    quantifier.setParameters(quant_param);
    // Isobaric quant run
    quantifier.quantify(map, deconvolved_spectra, deconvolved_features);
  }

  void FLASHDeconvAlgorithm::findPrecursorPeakGroupsFormIdaLog_(const MSExperiment& map, Size index, double start_mz, double end_mz)
  {
    if (precursor_map_for_ida_.empty())
      return;

    int scan_number = getScanNumber_(map, index);
    auto iter = precursor_map_for_ida_.lower_bound(scan_number);

    while (iter != precursor_map_for_ida_.begin() && native_id_precursor_peak_group_map_.find(map[index].getNativeID()) == native_id_precursor_peak_group_map_.end())
    {
      if (iter->first > scan_number || iter == precursor_map_for_ida_.end()){
        iter--;
        continue;
      }
      if (iter->first < scan_number - preceding_MS1_count_ - 500) // for FLASHIda, give more buffer scans
      {
        return;
      }

      if (iter != precursor_map_for_ida_.end())
      {
        for (auto& smap : iter->second)
        {
          if (abs(start_mz - smap[3]) < .001 && abs(end_mz - smap[4]) < .001)
          {
            FLASHDeconvHelperStructs::LogMzPeak precursor_log_mz_peak;
            precursor_log_mz_peak.abs_charge = std::abs((int)smap[1]);
            precursor_log_mz_peak.is_positive = (int)smap[1] > 0;
            precursor_log_mz_peak.isotopeIndex = 0;
            precursor_log_mz_peak.mass = smap[0];
            precursor_log_mz_peak.intensity = smap[6];

            PeakGroup precursor_pg;
            precursor_pg.push_back(precursor_log_mz_peak);
            precursor_pg.setAbsChargeRange(std::abs((int)smap[7]), std::abs((int)smap[8]));
            precursor_pg.setChargeIsotopeCosine(precursor_log_mz_peak.abs_charge, smap[9]);
            precursor_pg.setChargeSNR(precursor_log_mz_peak.abs_charge, smap[10]); // cnsr
            precursor_pg.setIsotopeCosine(smap[11]);
            precursor_pg.setSNR(smap[12]);
            precursor_pg.setChargeScore(smap[13]);
            precursor_pg.setAvgPPMError(smap[14]);
            precursor_pg.setQscore(smap[2]);
            precursor_pg.setRepAbsCharge(precursor_log_mz_peak.abs_charge);
            precursor_pg.updateMonoMassAndIsotopeIntensities();
            precursor_pg.setScanNumber(scan_number);
            native_id_precursor_peak_group_map_[map[index].getNativeID()] = precursor_pg;
            break;
          }
        }
      }
      --iter;
    }
  }

  void FLASHDeconvAlgorithm::findPrecursorPeakGroupsForMSnSpectra_(const MSExperiment& map, const std::vector<DeconvolvedSpectrum>& deconvolved_spectra, uint ms_level)
  {
    for (Size index = 0; index < map.size(); index++)
    {
      auto spec = map[index];
      if (spec.getMSLevel() != ms_level)
      {
        continue;
      }

      int scan_number = getScanNumber_(map, index);
      String native_id = spec.getNativeID();
      // find all candidate scan numbers from ms_level - 1
      int num_preceding = ms_level == 2 ? preceding_MS1_count_ : 1;
      auto index_copy = index;
      while (index_copy > 0 && num_preceding > 0)
      {
        index_copy--;
        if (map[index_copy].getMSLevel() == ms_level - 1)
        {
          num_preceding--;
        }
      }
      int b_scan_number = getScanNumber_(map, index_copy);

      // then find deconvolved spectra within the scan numbers.
      auto diter = std::lower_bound(deconvolved_spectra.begin(), deconvolved_spectra.end(), DeconvolvedSpectrum(b_scan_number));

      if (diter == deconvolved_spectra.end())
        continue;

      std::vector<DeconvolvedSpectrum> survey_scans;

      // exclude decoy ones.
      while (diter < deconvolved_spectra.end() && diter->getScanNumber() < scan_number)
      {
        if (diter->getOriginalSpectrum().getMSLevel() == ms_level - 1 && !diter->isDecoy())
        {
          survey_scans.push_back(*diter);
        }
        diter++;
      }

      // register the best precursor, starting from the most recent one. Out of the masses in a single scan, use the max SNR one.

      double start_mz = 0;
      double end_mz = 0;
      for (auto& precursor : spec.getPrecursors())
      {
        double loffset = precursor.getIsolationWindowLowerOffset();
        double uoffest = precursor.getIsolationWindowUpperOffset();
        loffset = loffset <= 0 ? isolation_window_size_ / 2.0 : loffset;
        uoffest = uoffest <= 0 ? isolation_window_size_ / 2.0 : uoffest;

        start_mz = loffset > 100.0 ? loffset : -loffset + precursor.getMZ();
        end_mz = uoffest > 100.0 ? uoffest : uoffest + precursor.getMZ();
      }
      double max_score = -1.0;

      for (int i = (int)survey_scans.size() - 1; i >= 0; i--)
      {
        auto precursor_spectrum = survey_scans[i];

        if (precursor_spectrum.empty())
        {
          continue;
        }
        auto o_spec = precursor_spectrum.getOriginalSpectrum();

        for (auto& pg : precursor_spectrum)
        {
          if (pg[0].mz > end_mz || pg.back().mz < start_mz)
          {
            continue;
          }

          double max_intensity = .0;
          const FLASHDeconvHelperStructs::LogMzPeak* tmp_precursor = nullptr;

          int c = int(.5 + pg.getMonoMass() / start_mz);
          for (auto& tmp_peak : pg)
          {
            if (tmp_peak.abs_charge != c)
            {
              continue;
            }

            if (tmp_peak.mz < start_mz || tmp_peak.mz > end_mz)
            {
              continue;
            }

            if (tmp_peak.intensity < max_intensity)
            {
              continue;
            }
            max_intensity = tmp_peak.intensity;
            tmp_precursor = &tmp_peak;
          }

          if (tmp_precursor == nullptr)
          {
            continue;
          }

          auto score = pg.getChargeSNR(tmp_precursor->abs_charge); // most intense one should determine the mass
          if (score < max_score)
          {
            continue;
          }
          max_score = score;
          native_id_precursor_peak_group_map_[native_id] = pg;
        }
        if (native_id_precursor_peak_group_map_.find(native_id) != native_id_precursor_peak_group_map_.end())
        {
          break;
        }
      }

      if (native_id_precursor_peak_group_map_.find(native_id) == native_id_precursor_peak_group_map_.end())
      {
        findPrecursorPeakGroupsFormIdaLog_(map, index, start_mz, end_mz);
      }
    }
  }

  void FLASHDeconvAlgorithm::updatePrecursorQScores_(std::vector<DeconvolvedSpectrum>& deconvolved_spectra, int ms_level)
  {
    // update precursor feature QScores and qvalues
    std::map<int, DeconvolvedSpectrum> scan_fullscan;

    for (auto& dspec : deconvolved_spectra)
    {
      if (dspec.getOriginalSpectrum().getMSLevel() != ms_level - 1)
        continue;
      int scan = dspec.getScanNumber();
      scan_fullscan[scan] = dspec;
    }

    for (auto& dspec : deconvolved_spectra)
    {
      if (dspec.getOriginalSpectrum().getMSLevel() != ms_level)
        continue;
      if (dspec.getPrecursorPeakGroup().empty())
        continue;

      auto precursor_pg = dspec.getPrecursorPeakGroup();

      int pscan = precursor_pg.getScanNumber();
      if (scan_fullscan.find(pscan) == scan_fullscan.end())
        continue;

      auto fullscan = scan_fullscan[pscan];

      auto iter = std::lower_bound(fullscan.begin(), fullscan.end(), precursor_pg);

      if (iter == fullscan.end())
        continue;

      if (precursor_pg.getMonoMass() == iter->getMonoMass())
      {
        precursor_pg.setFeatureIndex(iter->getFeatureIndex());
        precursor_pg.setQscore(iter->getQscore());
        if (iter->getFeatureIndex() > 0)
          precursor_pg.setQscore2D(iter->getQscore2D());
      }
      else
      {
        precursor_pg.setFeatureIndex(0);
      }
      dspec.setPrecursorPeakGroup(precursor_pg);
    }
  }

  void FLASHDeconvAlgorithm::runFeatureFinding_(std::vector<DeconvolvedSpectrum>& deconvolved_spectra, std::vector<FLASHDeconvHelperStructs::MassFeature>& deconvolved_features)
  {
    if (merge_spec_ == 2)
      return;

    auto mass_tracer = MassFeatureTrace();
    auto decoy_mass_tracer = MassFeatureTrace();

    Param mf_param = param_.copy("ft:", true);

    if (((double)mf_param.getValue("mass_error_ppm")) < 0)
    {
      mf_param.setValue("mass_error_ppm", tols_[0]);
    }
    if (((double)mf_param.getValue("min_cos")) < 0)
    {
      mf_param.setValue("min_cos", min_cos_[0]);
    }

    mf_param.setValue("noise_threshold_int", .0);
    mf_param.setValue("reestimate_mt_sd", "false");
    mf_param.setValue("trace_termination_criterion", "outlier");
    mf_param.setValue("trace_termination_outliers", 20);
    mf_param.setValue("chrom_peak_snr", .0);

    mass_tracer.setParameters(mf_param); // maybe go to set param
    // decoy_mass_tracer.setParameters(mf_param);
    // Find features for MS1 or the minimum MS level in the dataset.
    deconvolved_features = mass_tracer.findFeaturesAndUpdateQscore2D(sd_.getAveragine(), deconvolved_spectra, current_min_ms_level_, false);

    if (report_decoy_)
    {
      auto decoy_deconvolved_features = mass_tracer.findFeaturesAndUpdateQscore2D(sd_.getAveragine(), deconvolved_spectra, current_min_ms_level_, true);
      deconvolved_features.insert(deconvolved_features.end(), decoy_deconvolved_features.begin(), decoy_deconvolved_features.end());
    }

    mf_param.setValue("min_trace_length", 1e-5); // allow all traces for MSn
    mass_tracer.setParameters(mf_param);
    // Find features for MSn
    for (int ms_level = current_min_ms_level_ + 1; ms_level <= current_max_ms_level_; ms_level++)
    {
      updatePrecursorQScores_(deconvolved_spectra, ms_level);
      std::map<uint, std::vector<Size>> feature_index_set;
      for (Size i = 0; i < deconvolved_spectra.size(); i++)
      {
        const auto& dspec = deconvolved_spectra[i];
        if (dspec.getOriginalSpectrum().getMSLevel() != ms_level)
          continue;
        if (dspec.getPrecursorPeakGroup().empty())
          continue;
        uint findex = dspec.getPrecursorPeakGroup().getFeatureIndex();
        if (findex == 0)
          continue;
        feature_index_set[findex].push_back(i);
      }

      for (auto& element : feature_index_set)
      {
        std::vector<DeconvolvedSpectrum> tmp_dspec;
        tmp_dspec.reserve(element.second.size());
        for (Size i : element.second)
          tmp_dspec.push_back(deconvolved_spectra[i]);

        auto df = mass_tracer.findFeaturesAndUpdateQscore2D(sd_.getAveragine(), tmp_dspec, ms_level, false);
        deconvolved_features.insert(deconvolved_features.end(), df.begin(), df.end());

        if (report_decoy_)
        {
          auto df_decoy = mass_tracer.findFeaturesAndUpdateQscore2D(sd_.getAveragine(), tmp_dspec, ms_level, true);
          deconvolved_features.insert(deconvolved_features.end(), df.begin(), df.end());
        }

        Size j = 0;
        for (Size i : element.second)
          deconvolved_spectra[i] = tmp_dspec[j++];
      }
    }
  }
} // namespace OpenMS